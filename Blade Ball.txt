
local workspace = game:GetService("Workspace")
local players = game:GetService("Players")
local replicatedStorage = game:GetService("ReplicatedStorage")
local localPlayer = players.LocalPlayer
local BASE_THRESHOLD = 0.2
local VELOCITY_SCALING_FACTOR_FAST = 0.050
local VELOCITY_SCALING_FACTOR_SLOW = 0.1
local IMMEDIATE_PARRY_DISTANCE = 15
local IMMEDIATE_HIGH_VELOCITY_THRESHOLD = 85
local UserInputService = game:GetService("UserInputService")
local responses = {"lol what", "??", "wdym", "bru what", "mad cuz bad", "skill issue", "cry"}
local gameEndResponses = {"ggs", "gg :3", "good game", "ggs yall", "wp", "ggs man"}
local keywords = {"auto parry", "auto", "cheating", "hacking"}
local heartbeatConnection
local focusedBall, displayBall = nil, nil
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local ballsFolder = workspace:WaitForChild("Balls")
local parryButtonPress = replicatedStorage.Remotes.ParryButtonPress
local abilityButtonPress = replicatedStorage.Remotes.AbilityButtonPress
local sliderValue = 20
local distanceVisualizer = nil
local isRunning = false
local notifyparried = false
local PlayerGui = localPlayer:WaitForChild("PlayerGui")
local Hotbar = PlayerGui:WaitForChild("Hotbar")
local UseRage = false

local uigrad1 = Hotbar.Block.border1.UIGradient
local uigrad2 = Hotbar.Ability.border2.UIGradient


local function isPlayerOnMobile()
    return UserInputService.TouchEnabled and not (UserInputService.KeyboardEnabled or UserInputService.GamepadEnabled)
end

if character then
    print("Character found.")
else
    print("Character not found.")
    return
end

local function notify(title, content, duration)
    Rayfield:Notify({
        Title = title,
        Content = content,
        Duration = duration or 0.7,
        Image = 10010348543
    })
end

local function chooseNewFocusedBall1()
    local balls = ballsFolder:GetChildren()
    for _, ball in ipairs(balls) do
        if ball:GetAttribute("realBall") ~= nil and ball:GetAttribute("realBall") == true then
            focusedBall = ball
            print(focusedBall.Name)
            break
        elseif ball:GetAttribute("target") ~= nil then
            focusedBall = ball
            print(focusedBall.Name)
            break
        end
    end
    
    if focusedBall == nil then
        print("Debug: Could not find a ball that's the realBall or has a target.")
        wait(1)
        chooseNewFocusedBall1()
    end
    return focusedBall
end

local function getDynamicThreshold(ballVelocityMagnitude)
    if ballVelocityMagnitude > 60 then
        return math.max(0.20, BASE_THRESHOLD - (ballVelocityMagnitude * VELOCITY_SCALING_FACTOR_FAST))
    else
        return math.min(0.01, BASE_THRESHOLD + (ballVelocityMagnitude * VELOCITY_SCALING_FACTOR_SLOW))
    end
end

local function timeUntilImpact(ballVelocity, distanceToPlayer, playerVelocity)
    if not character then return end
    local directionToPlayer = (character.HumanoidRootPart.Position - focusedBall.Position).Unit
    local velocityTowardsPlayer = ballVelocity:Dot(directionToPlayer) - playerVelocity:Dot(directionToPlayer)
    
    if velocityTowardsPlayer <= 0 then
        return math.huge
    end
    
    return (distanceToPlayer - sliderValue) / velocityTowardsPlayer
end

local function updateDistanceVisualizer()
    local charPos = character and character.PrimaryPart and character.PrimaryPart.Position
    if charPos and focusedBall then
        if distanceVisualizer then
            distanceVisualizer:Destroy()
        end

        local timeToImpactValue = timeUntilImpact(focusedBall.Velocity, (focusedBall.Position - charPos).Magnitude, character.PrimaryPart.Velocity)
        local ballFuturePosition = focusedBall.Position + focusedBall.Velocity * timeToImpactValue

        distanceVisualizer = Instance.new("Part")
        distanceVisualizer.Size = Vector3.new(1, 1, 1)
        distanceVisualizer.Anchored = true
        distanceVisualizer.CanCollide = false
        distanceVisualizer.Position = ballFuturePosition
        distanceVisualizer.Parent = workspace    
    end
end

local function checkIfTarget()
    for _, v in pairs(ballsFolder:GetChildren()) do
        if v:IsA("Part") and v.BrickColor == BrickColor.new("Really red") then 
            print("Ball is targetting player.")
            return true 
        end 
    end 
    return false
end

local function isCooldownInEffect(uigradient)
    return uigradient.Offset.Y < 0.5
end


local function checkBallDistance1()
    if not character or not checkIfTarget() then return end

    local charPos = character.PrimaryPart.Position
    local charVel = character.PrimaryPart.Velocity

    if focusedBall and not focusedBall.Parent then
        print("Focused ball lost parent. Choosing a new focused ball.")
        chooseNewFocusedBall1()
    end
    if not focusedBall then 
        print("No focused ball.")
        chooseNewFocusedBall1()
    end

    local ball = focusedBall
    local distanceToPlayer = (ball.Position - charPos).Magnitude
    local ballVelocityTowardsPlayer = ball.Velocity:Dot((charPos - ball.Position).Unit)
    
    if distanceToPlayer < 15 then
        parryButtonPress:Fire()
        task.wait()
    end

    if timeUntilImpact(ball.Velocity, distanceToPlayer, charVel) < getDynamicThreshold(ballVelocityTowardsPlayer) then
        if (character.Abilities["Raging Deflection"].Enabled or character.Abilities["Rapture"].Enabled) and UseRage == true then
            if not isCooldownInEffect(uigrad2) then
                abilityButtonPress:Fire()
            end

            if isCooldownInEffect(uigrad2) and not isCooldownInEffect(uigrad1) then
                parryButtonPress:Fire()
                if notifyparried == true then
                    notify("Auto Parry", "Manually Parried Ball (Ability on CD)", 0.3)
                end
            end

        elseif not isCooldownInEffect(uigrad1) then
            print(isCooldownInEffect(uigrad1))
            parryButtonPress:Fire()
            if notifyparried == true then
                notify("Auto Parry", "Automatically Parried Ball", 0.3)
            end
            task.wait(0.3)
        end
    end
end


local function autoParryCoroutine()
    while isRunning do
        checkBallDistance1()
        updateDistanceVisualizer()
        task.wait()
    end
end



localPlayer.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    chooseNewFocusedBall1()
    updateDistanceVisualizer()
end)

localPlayer.CharacterRemoving:Connect(function()
    if distanceVisualizer then
        distanceVisualizer:Destroy()
        distanceVisualizer = nil
    end
end)



local function startAutoParry1()
    print("Script successfully ran.")
    
    chooseNewFocusedBall1()
    
    isRunning = true
    local co = coroutine.create(autoParryCoroutine)
    coroutine.resume(co)
end

local function stopAutoParry1()
    isRunning = false
end

local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/VnTotalGui/vngui/main/RayfeildCustome'))()

local runService = game:GetService("RunService")
local workspace = game:GetService("Workspace")
local players = game:GetService("Players")
local localPlayer = players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local abilitiesFolder = character:WaitForChild("Abilities")
local UserInputService = game:GetService("UserInputService")
local replicatedStorage = game:GetService("ReplicatedStorage")
local heartbeatConnection
local upgrades = localPlayer.Upgrades
local UseRage = false
local sliderValue = 20

local function onCharacterAdded(newCharacter)
    character = newCharacter
    abilitiesFolder = character:WaitForChild("Abilities")
end

localPlayer.CharacterAdded:Connect(onCharacterAdded)

local TruValue = Instance.new("StringValue")
if workspace:FindFirstChild("AbilityThingyk1212") then
    workspace:FindFirstChild("AbilityThingyk1212"):Remove()
    task.wait(0.1)
    TruValue.Parent = game:GetService("Workspace")
        TruValue.Name = "AbilityThingyk1212"
        TruValue.Value = "Dash" --Change to Use other ability
    else
        TruValue.Parent = game:GetService("Workspace")
        TruValue.Name = "AbilityThingyk1212"
        TruValue.Value = "Dash" --Change to Use other ability
end

local Window = Rayfield:CreateWindow({
   Name = ".",
   LoadingTitle = ".",
   LoadingSubtitle = ".",
   ConfigurationSaving = {
      Enabled = true,
      FolderName = ".",
      FileName = "Configuration"
   },
   Discord = {
      Enabled = false,
      Invite = "gNKfqqjYvg",
      RememberJoins = true
   },
   KeySystem = false,
   KeySettings = {
      Title = "IDK",
      Subtitle = "Key System",
      Note = "null",
      FileName = "??",
      SaveKey = true,
      GrabKeyFromSite = false,
      Key = ""
   }
})

local AutoParry = Window:CreateTab("Main", 13014537525)

local Skins = Window:CreateTab("Skin", 262609511)
local Misc2 = Window:CreateTab("Misc2", 262609511)



local function startAutoParry()
    local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
    local ballsFolder = workspace:WaitForChild("Balls")
    local parryButtonPress = replicatedStorage.Remotes.ParryButtonPress
    local abilityButtonPress = replicatedStorage.Remotes.AbilityButtonPress


    local function onCharacterAdded(newCharacter)
        character = newCharacter
    end
    localPlayer.CharacterAdded:Connect(onCharacterAdded)

    if character then
        
    else
        
        return
    end
    

local function chooseNewFocusedBall()
    local balls = ballsFolder:GetChildren()
    for _, ball in ipairs(balls) do
        if ball:GetAttribute("realBall") ~= nil and ball:GetAttribute("realBall") == true then
            focusedBall = ball
            print(focusedBall.Name)
            break
        elseif ball:GetAttribute("target") ~= nil then
            focusedBall = ball
            print(focusedBall.Name)
            break
        end
    end
    
    if focusedBall == nil then
        
    end
    return focusedBall
end





    chooseNewFocusedBall()

    local BASE_THRESHOLD = 0.15
    local VELOCITY_SCALING_FACTOR_FAST = 0.050
    local VELOCITY_SCALING_FACTOR_SLOW = 0.1

    local function getDynamicThreshold(ballVelocityMagnitude)
        if ballVelocityMagnitude > 60 then
            
            return math.max(0.20, BASE_THRESHOLD - (ballVelocityMagnitude * VELOCITY_SCALING_FACTOR_FAST))
        else
            return math.min(0.01, BASE_THRESHOLD + (ballVelocityMagnitude * VELOCITY_SCALING_FACTOR_SLOW))
        end
    end

    local function timeUntilImpact(ballVelocity, distanceToPlayer, playerVelocity)
        local directionToPlayer = (character.HumanoidRootPart.Position - focusedBall.Position).Unit
        local velocityTowardsPlayer = ballVelocity:Dot(directionToPlayer) - playerVelocity:Dot(directionToPlayer)
        
        if velocityTowardsPlayer <= 0 then
            return math.huge
        end
        
        return (distanceToPlayer - sliderValue) / velocityTowardsPlayer
    end

    local function isWalkSpeedZero()
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            return humanoid.WalkSpeed == 0
        end
        return false
    end


    local function checkBallDistance()
        if not character or not character:FindFirstChild("Highlight") then return end

        local charPos = character.PrimaryPart.Position
        local charVel = character.PrimaryPart.Velocity

        if focusedBall and not focusedBall.Parent then
            
            chooseNewFocusedBall()
        end
        if not focusedBall then 
            
            chooseNewFocusedBall()
        end

        local ball = focusedBall
        local distanceToPlayer = (ball.Position - charPos).Magnitude
        local ballVelocityTowardsPlayer = ball.Velocity:Dot((charPos - ball.Position).Unit)
        
        if distanceToPlayer < 10 then
            parryButtonPress:Fire()
        end
        local isCheckingRage = false

        if timeUntilImpact(ball.Velocity, distanceToPlayer, charVel) < getDynamicThreshold(ballVelocityTowardsPlayer) then
            if character.Abilities["Raging Deflection"].Enabled and UseRage == true then
                if not isCheckingRage then
                    isCheckingRage = true
                    abilityButtonPress:Fire()
                    if not isWalkSpeedZero() then
                        parryButtonPress:Fire()
                    end
                    isCheckingRage = false
                end
            else
                parryButtonPress:Fire()
            end
        end
    end


    heartbeatConnection = game:GetService("RunService").Heartbeat:Connect(function()
        checkBallDistance()
    end)
end

local function stopAutoParry()
    if heartbeatConnection then
        heartbeatConnection:Disconnect()
        heartbeatConnection = nil
    end
end

local AutoParrySection = AutoParry:CreateSection("Auto-Parry")

local AutoParryToggle = AutoParry:CreateToggle({
    Name = "AutoParry",
    CurrentValue = false,
    Flag = "AutoParryFlag",
    Callback = function(Value)
        if Value then
            startAutoParry()
        else
            stopAutoParry()
        end
    end,
})


local Configuration = AutoParry:CreateSection("Configuration")

local DistanceSlider = AutoParry:CreateSlider({
   Name = "Distance",
   Range = {0, 100},
   Increment = 1,
   Suffix = "Distance (20 is safe)",
   CurrentValue = 20,
   Flag = "DistanceSlider",
   Callback = function(Value)
       sliderValue = Value
   end,
})


local ToggleParryOn = AutoParry:CreateKeybind({
   Name = "Parry On/Off",
   CurrentKeybind = "T",
   HoldToInteract = false,
   Flag = "ToggleParryOn", 
   Callback = function(Keybind)
AutoParryToggle:Set(not AutoParryToggle.CurrentValue)

   end
})

local ChangeDistanceToidk = AutoParry:CreateKeybind({
    Name = "Distance to 20",
    CurrentKeybind = "V",
    HoldToInteract = false,
    Flag = "Distanceto100", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Keybind)
 DistanceSlider:Set(20) -- The new slider integer value
    end,
 })

local ChangeDistanceToidk = AutoParry:CreateKeybind({
   Name = "Distance to 100",
   CurrentKeybind = "B",
   HoldToInteract = false,
   Flag = "Distanceto100", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Keybind)
DistanceSlider:Set(100) -- The new slider integer value
   end,
})


local AntiAfkThing = AutoParry:CreateSection("Anti Afk")
local Toggle = AutoParry:CreateToggle({
   Name = "Anti Afk",
   CurrentValue = false,
   Flag = "AntiAfk", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
        AntiAfkLol = Value
                while true do wait()
            if AntiAfkLol then
local vu = game:GetService("VirtualUser")
game:GetService("Players").LocalPlayer.Idled:connect(function()
   vu:Button2Down(Vector2.new(0,0),workspace.CurrentCamera.CFrame)
   wait(1)
   vu:Button2Up(Vector2.new(0,0),workspace.CurrentCamera.CFrame)
end)
        end
    end
   end,
})

local CloseFighting = AutoParry:CreateSection("Close Fighting")
local SpamParry = AutoParry:CreateKeybind({
   Name = "Spam Parry (Hold)",
   CurrentKeybind = "C",
   HoldToInteract = true,
   Flag = "ToggleParrySpam", 
   Callback = function(Keybind)
            local function click(a)
    game:GetService("VirtualInputManager"):SendMouseButtonEvent(a.AbsolutePosition.X+a.AbsoluteSize.X/2,a.AbsolutePosition.Y+50,0,true,a,1)
    game:GetService("VirtualInputManager"):SendMouseButtonEvent(a.AbsolutePosition.X+a.AbsoluteSize.X/2,a.AbsolutePosition.Y+50,0,false,a,1)
end

click(game:GetService("Players").LocalPlayer.PlayerGui.Hotbar.Block.Pressable1)
   end,
})

local AfkThing = AutoParry:CreateSection("Afk Farm")
local TpToSpawn = AutoParry:CreateToggle({
    Name = "Spawn Tp",
    CurrentValue = false,
    Flag = "SpawnTp",
    Callback = function(Value)
        TpSpawn = Value

        spawn(function()
                while true do wait()
                if TpSpawn then
                    character.HumanoidRootPart.CFrame = CFrame.new(-229, 123, 203)
                    end
                end
            end)
    end,
})

local Height = AutoParry:CreateSlider({
    Name = "Invisible Platform",
    Range = {0, 100},
    Increment = 10,
    Suffix = "Height",
    CurrentValue = 10,
    Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value11)
        character.Humanoid.HipHeight = Value11
        end,
 })


local Main = Window:CreateTab("FreeSkill", 262609511)
local Abilities = Main:CreateSection("Skill")

local AliveFolder = Misc:CreateButton({
   Name = "Use SKill in lobby",
   Callback = function()
    character.Parent = workspace.Alive
end
})


local Dash = Main:CreateButton({
   Name = "Dash",
   Callback = function()
local args = {
    [1] = "Dash"
}

game:GetService("ReplicatedStorage").Remotes.Store.RequestEquipAbility:InvokeServer(unpack(args))

game:GetService("ReplicatedStorage").Remotes.Store.GetOwnedAbilities:InvokeServer()

game:GetService("ReplicatedStorage").Remotes.kebaind:FireServer()

    local function AbilityValue2()
local TruValue = Instance.new("StringValue")
workspace:FindFirstChild("AbilityThingyk1212"):Remove()
        TruValue.Parent = game:GetService("Workspace")
        TruValue.Name = "AbilityThingyk1212"
        TruValue.Value = "Dash" --Change to Use other ability

end

for i,v in pairs(abilitiesFolder:GetChildren()) do


for i,b in pairs(abilitiesFolder:GetChildren()) do
    local Ability = b
    
    if v.Enabled == true then
        local EquippedAbility = v
        local ChosenAbility = {}
        spawn(function()
        ChosenAbility = AbilityValue2()
    end)

    task.wait(0.05)
        local AbilityValue = workspace.AbilityThingyk1212
        if b.Name == AbilityValue.Value then

            v.Enabled = false
            b.Enabled = true
    end
end
end
end
   end,
})

local Forcefield = Main:CreateButton({
   Name = "Forcefield",
   Callback = function()

local args = {
    [1] = "Forcefield"
}

game:GetService("ReplicatedStorage").Remotes.Store.RequestEquipAbility:InvokeServer(unpack(args))

game:GetService("ReplicatedStorage").Remotes.Store.GetOwnedAbilities:InvokeServer()

game:GetService("ReplicatedStorage").Remotes.kebaind:FireServer()
            
local function AbilityValue2()
local TruValue = Instance.new("StringValue")
workspace:FindFirstChild("AbilityThingyk1212"):Remove()
        TruValue.Parent = game:GetService("Workspace")
        TruValue.Name = "AbilityThingyk1212"
        TruValue.Value = "Forcefield" --Change to Use other ability
end

for i,v in pairs(abilitiesFolder:GetChildren()) do


for i,b in pairs(abilitiesFolder:GetChildren()) do
    local Ability = b
    
    if v.Enabled == true then
        local EquippedAbility = v
        local ChosenAbility = {}
        spawn(function()
        ChosenAbility = AbilityValue2()
    end)

    task.wait(0.05)
        local AbilityValue = workspace.AbilityThingyk1212
        if b.Name == AbilityValue.Value then

            v.Enabled = false
            b.Enabled = true
    end
end
end
end
   end,
})

local Invisibility = Main:CreateButton({
   Name = "Invisibility",
   Callback = function()

local args = {
    [1] = "Invisibility"
}

game:GetService("ReplicatedStorage").Remotes.Store.RequestEquipAbility:InvokeServer(unpack(args))

game:GetService("ReplicatedStorage").Remotes.Store.GetOwnedAbilities:InvokeServer()

game:GetService("ReplicatedStorage").Remotes.kebaind:FireServer()
            
local function AbilityValue2()
local TruValue = Instance.new("StringValue")
workspace:FindFirstChild("AbilityThingyk1212"):Remove()
        TruValue.Parent = game:GetService("Workspace")
        TruValue.Name = "AbilityThingyk1212"
        TruValue.Value = "Invisibility" --Change to Use other ability
end

for i,v in pairs(abilitiesFolder:GetChildren()) do


for i,b in pairs(abilitiesFolder:GetChildren()) do
    local Ability = b
    
    if v.Enabled == true then
        local EquippedAbility = v
        local ChosenAbility = {}
        spawn(function()
        ChosenAbility = AbilityValue2()
    end)

    task.wait(0.05)
        local AbilityValue = workspace.AbilityThingyk1212
        if b.Name == AbilityValue.Value then

            v.Enabled = false
            b.Enabled = true
    end
end
end
end
   end,
})

local Platform = Main:CreateButton({
   Name = "Platform",
   Callback = function()

local args = {
    [1] = "Platform"
}

game:GetService("ReplicatedStorage").Remotes.Store.RequestEquipAbility:InvokeServer(unpack(args))

game:GetService("ReplicatedStorage").Remotes.Store.GetOwnedAbilities:InvokeServer()

game:GetService("ReplicatedStorage").Remotes.kebaind:FireServer()
            
local function AbilityValue2()
local TruValue = Instance.new("StringValue")
workspace:FindFirstChild("AbilityThingyk1212"):Remove()
        TruValue.Parent = game:GetService("Workspace")
        TruValue.Name = "AbilityThingyk1212"
        TruValue.Value = "Platform" --Change to Use other ability
end

for i,v in pairs(abilitiesFolder:GetChildren()) do


for i,b in pairs(abilitiesFolder:GetChildren()) do
    local Ability = b
    
    if v.Enabled == true then
        local EquippedAbility = v
        local ChosenAbility = {}
        spawn(function()
        ChosenAbility = AbilityValue2()
    end)

    task.wait(0.05)
        local AbilityValue = workspace.AbilityThingyk1212
        if b.Name == AbilityValue.Value then

            v.Enabled = false
            b.Enabled = true
    end
end
end
end
   end,
})

local RagingDeflection = Main:CreateButton({
   Name = "Raging Deflection",
   Callback = function()

local args = {
    [1] = "Raging Deflection"
}

game:GetService("ReplicatedStorage").Remotes.Store.RequestEquipAbility:InvokeServer(unpack(args))

game:GetService("ReplicatedStorage").Remotes.Store.GetOwnedAbilities:InvokeServer()

game:GetService("ReplicatedStorage").Remotes.kebaind:FireServer()
            
local function AbilityValue2()
local TruValue = Instance.new("StringValue")
workspace:FindFirstChild("AbilityThingyk1212"):Remove()
        TruValue.Parent = game:GetService("Workspace")
        TruValue.Name = "AbilityThingyk1212"
        TruValue.Value = "Raging Deflection" --Change to Use other ability
end

for i,v in pairs(abilitiesFolder:GetChildren()) do


for i,b in pairs(abilitiesFolder:GetChildren()) do
    local Ability = b
    
    if v.Enabled == true then
        local EquippedAbility = v
        local ChosenAbility = {}
        spawn(function()
        ChosenAbility = AbilityValue2()
    end)

    task.wait(0.05)
        local AbilityValue = workspace.AbilityThingyk1212
        if b.Name == AbilityValue.Value then

            v.Enabled = false
            b.Enabled = true
    end
end
end
end
   end,
})

local ShadowStep = Main:CreateButton({
   Name = "Shadow Step",
   Callback = function()

local args = {
    [1] = "Shadow Step"
}

game:GetService("ReplicatedStorage").Remotes.Store.RequestEquipAbility:InvokeServer(unpack(args))

game:GetService("ReplicatedStorage").Remotes.Store.GetOwnedAbilities:InvokeServer()

game:GetService("ReplicatedStorage").Remotes.kebaind:FireServer()
            
local function AbilityValue2()
local TruValue = Instance.new("StringValue")
workspace:FindFirstChild("AbilityThingyk1212"):Remove()
        TruValue.Parent = game:GetService("Workspace")
        TruValue.Name = "AbilityThingyk1212"
        TruValue.Value = "Shadow Step" --Change to Use other ability
end

for i,v in pairs(abilitiesFolder:GetChildren()) do


for i,b in pairs(abilitiesFolder:GetChildren()) do
    local Ability = b
    
    if v.Enabled == true then
        local EquippedAbility = v
        local ChosenAbility = {}
        spawn(function()
        ChosenAbility = AbilityValue2()
    end)

    task.wait(0.05)
        local AbilityValue = workspace.AbilityThingyk1212
        if b.Name == AbilityValue.Value then

            v.Enabled = false
            b.Enabled = true
    end
end
end
end
   end,
})

local SuperJump = Main:CreateButton({
   Name = "Super Jump",
   Callback = function()

local args = {
    [1] = "Super Jump"
}

game:GetService("ReplicatedStorage").Remotes.Store.RequestEquipAbility:InvokeServer(unpack(args))

game:GetService("ReplicatedStorage").Remotes.Store.GetOwnedAbilities:InvokeServer()

game:GetService("ReplicatedStorage").Remotes.kebaind:FireServer()
            
local function AbilityValue2()
local TruValue = Instance.new("StringValue")
workspace:FindFirstChild("AbilityThingyk1212"):Remove()
        TruValue.Parent = game:GetService("Workspace")
        TruValue.Name = "AbilityThingyk1212"
        TruValue.Value = "Super Jump" --Change to Use other ability
end

for i,v in pairs(abilitiesFolder:GetChildren()) do


for i,b in pairs(abilitiesFolder:GetChildren()) do
    local Ability = b
    
    if v.Enabled == true then
        local EquippedAbility = v
        local ChosenAbility = {}
        spawn(function()
        ChosenAbility = AbilityValue2()
    end)

    task.wait(0.05)
        local AbilityValue = workspace.AbilityThingyk1212
        if b.Name == AbilityValue.Value then

            v.Enabled = false
            b.Enabled = true
    end
end
end
end
   end,
})

local Telekinesis = Main:CreateButton({
   Name = "Telekinesis",
   Callback = function()

local args = {
    [1] = "Telekinesis"
}

game:GetService("ReplicatedStorage").Remotes.Store.RequestEquipAbility:InvokeServer(unpack(args))

game:GetService("ReplicatedStorage").Remotes.Store.GetOwnedAbilities:InvokeServer()

game:GetService("ReplicatedStorage").Remotes.kebaind:FireServer()
            
local function AbilityValue2()
local TruValue = Instance.new("StringValue")
workspace:FindFirstChild("AbilityThingyk1212"):Remove()
        TruValue.Parent = game:GetService("Workspace")
        TruValue.Name = "AbilityThingyk1212"
        TruValue.Value = "Telekinesis" --Change to Use other ability
end

for i,v in pairs(abilitiesFolder:GetChildren()) do


for i,b in pairs(abilitiesFolder:GetChildren()) do
    local Ability = b
    
    if v.Enabled == true then
        local EquippedAbility = v
        local ChosenAbility = {}
        spawn(function()
        ChosenAbility = AbilityValue2()
    end)

    task.wait(0.05)
        local AbilityValue = workspace.AbilityThingyk1212
        if b.Name == AbilityValue.Value then

            v.Enabled = false
            b.Enabled = true
    end
end
end
end
   end,
})

local ThunderDash = Main:CreateButton({
   Name = "Thunder Dash",
   Callback = function()

local args = {
    [1] = "Thunder Dash"
}

game:GetService("ReplicatedStorage").Remotes.Store.RequestEquipAbility:InvokeServer(unpack(args))

game:GetService("ReplicatedStorage").Remotes.Store.GetOwnedAbilities:InvokeServer()

game:GetService("ReplicatedStorage").Remotes.kebaind:FireServer()
            
local function AbilityValue2()
local TruValue = Instance.new("StringValue")
workspace:FindFirstChild("AbilityThingyk1212"):Remove()
        TruValue.Parent = game:GetService("Workspace")
        TruValue.Name = "AbilityThingyk1212"
        TruValue.Value = "Thunder Dash" --Change to Use other ability
end

for i,v in pairs(abilitiesFolder:GetChildren()) do


for i,b in pairs(abilitiesFolder:GetChildren()) do
    local Ability = b
    
    if v.Enabled == true then
        local EquippedAbility = v
        local ChosenAbility = {}
        spawn(function()
        ChosenAbility = AbilityValue2()
    end)

    task.wait(0.05)
        local AbilityValue = workspace.AbilityThingyk1212
        if b.Name == AbilityValue.Value then

            v.Enabled = false
            b.Enabled = true
    end
end
end
end
   end,
})

local Telekinesis = Main:CreateButton({
   Name = "Rapture",
   Callback = function()

local args = {
    [1] = "Rapture"
}

game:GetService("ReplicatedStorage").Remotes.Store.RequestEquipAbility:InvokeServer(unpack(args))

game:GetService("ReplicatedStorage").Remotes.Store.GetOwnedAbilities:InvokeServer()

game:GetService("ReplicatedStorage").Remotes.kebaind:FireServer()
            
local function AbilityValue2()
local TruValue = Instance.new("StringValue")
workspace:FindFirstChild("AbilityThingyk1212"):Remove()
        TruValue.Parent = game:GetService("Workspace")
        TruValue.Name = "AbilityThingyk1212"
        TruValue.Value = "Rapture" --Change to Use other ability
end

for i,v in pairs(abilitiesFolder:GetChildren()) do


for i,b in pairs(abilitiesFolder:GetChildren()) do
    local Ability = b
    
    if v.Enabled == true then
        local EquippedAbility = v
        local ChosenAbility = {}
        spawn(function()
        ChosenAbility = AbilityValue2()
    end)

    task.wait(0.05)
        local AbilityValue = workspace.AbilityThingyk1212
        if b.Name == AbilityValue.Value then

            v.Enabled = false
            b.Enabled = true
    end
end
end
end
   end,
})


local InfSkill = Window:CreateTab("InfSkill", 262609511)
local Positive = InfSkill:CreateSection("Inf Skill")
local InfDash = InfSkill:CreateButton({
   Name =  "INF Dash ",
   Callback = function()
   upgrades:WaitForChild("Dash").Value = 999999999999999999
end
})

local infForcefield2 = InfSkill:CreateButton({
   Name = "Inf Forcefield",
   Callback = function()
   upgrades:WaitForChild("Forcefield").Value = 999999999999999999
end
})

local infInvisibility2 = InfSkill:CreateButton({
   Name = "INF Invisibility.",
   Callback = function()
   upgrades:WaitForChild("Invisibility").Value = 999999999999999999
end
})

local Platform = InfSkill:CreateButton({
   Name = "Inf Platform (Dont use cuz its stun you)",
   Callback = function()
   upgrades:WaitForChild("Platform").Value = 999999999999999999
end
})

local InfShadowStep = InfSkill:CreateButton({
   Name = "INF Shadow Step",
   Callback = function()
   upgrades:WaitForChild("Shadow Step").Value = 999999999999999999
end
})

local InfSuperJump = InfSkill:CreateButton({
   Name = "INF Super Jump",
   Callback = function()
   upgrades:WaitForChild("Super Jump").Value = 999999999999999999
end
})

local InfThunderDash = InfSkill:CreateButton({
   Name = "INF thunder dash",
   Callback = function()
   upgrades:WaitForChild("Thunder Dash").Value = 999999999999999999
end
})

local RageDeflecter = InfSkill:CreateButton({
   Name = "Inf Raging Deflection ",
   Callback = function()
   upgrades:WaitForChild("Raging Deflection").Value = 999999999999999999
end
})

local StrongerTelekines = InfSkill:CreateButton({
   Name = "INF Telekinesis",
   Callback = function()
   upgrades:WaitForChild("Telekinesis").Value = 999999999999999999
end
})


local emotes = Misc:CreateSection("Emote")

local EmoteEffect = Misc:CreateButton({
   Name = "FREE Gamepass emote + music",
   Callback = function()
   local args = {[1] = true,[2] = "Empyrean"}game:GetService("ReplicatedStorage").Remotes.CustomEmote:FireServer(unpack(args))
end
})

local ActualEmote = Misc:CreateButton({
   Name = "FREE Gamepass emote JOJO",
   Callback = function()
   character:FindFirstChildOfClass("Model").Name = "Empyrean Greatblade"
end
})

local ResetCD = Misc:CreateButton({
   Name = "Reset Cooldown",
   Callback = function()
    character.HumanoidRootPart.CFrame = CFrame.new(-10002.240021, 123.299988, 200.441544)
    task.wait(1)
   character.Humanoid.Health = 0
end
})

local Limiteds = Skins:CreateSection("Limited Skin")

local EmpyrianSword = Skins:CreateButton({
   Name = "Greatblade",
   Callback = function()
            local localplayer = game.Players.LocalPlayer
local character = localplayer.Character
local Katanamesh = character:FindFirstChildOfClass("Model"):FindFirstChild("KatanaMesh")
local Empyreansword = game:GetService("ReplicatedStorage").Misc.Swords.Limited["Empyrean Greatblade"]

local SkinSword = Empyreansword:FindFirstChild("Meshes/Sword")
local SkinSwordClone = Empyreansword:FindFirstChild("Meshes/Sword"):Clone()

SkinSwordClone.Anchored = false
SkinSwordClone.Parent = character:FindFirstChildOfClass("Model")
SkinSwordClone.CFrame = Katanamesh.CFrame
local katmesh = Katanamesh
local weldthing = Instance.new("Weld")
weldthing.Parent = SkinSwordClone
weldthing.Part0 = SkinSwordClone
weldthing.Part1 = katmesh
katmesh.Transparency = 1

character.HumanoidRootPart.CFrame = CFrame.new(-233.710556, 123.299973, 203.648102)
task.wait(0.1)
SkinSwordClone.Rotation = Vector3.new(-75.41799926757812, -90, 0)


end
})

local OniClaws = Skins:CreateButton({
   Name = "Oni Claws",
   Callback = function()


local bindableFunction= Instance.new("BindableFunction")
game.StarterGui:SetCore("SendNotification", {
   Title = "Wave Hub";
   Text = "Sucessfully use Oni Claws";
   Icon = "";
   Duration = 4;
   callbakc = bindableFunction;
   Button1 = "OK";
})

            
    local localplayer = game.Players.LocalPlayer
local character = localplayer.Character
local sword = character:FindFirstChildOfClass("Model")
local claws = game:GetService("ReplicatedStorage").Misc.Swords.Limited["Oni Claws"]:Clone()
local Katanamesh = character:FindFirstChildOfClass("Model"):FindFirstChild("KatanaMesh")
local Cestsu1 = claws.Cestus
local Cestsu2 = claws.Cestus2

local Glove = claws
local Cestus1 = Glove:FindFirstChild("Cestus")
local Cestus1Blade = Cestus1:FindFirstChild("Meshes/oni claws textured_Cube.010_Cube.020")
local thing = Cestus1Blade
local Cestus2 = Glove:FindFirstChild("Cestus2")

Glove.Parent = sword
local leftarm = Instance.new("Weld")
leftarm.Name = "Left Arm"
leftarm.Parent = Cestus1
leftarm.Part0 = Cestus1.zaza
leftarm.Part1 = character:FindFirstChild("Left Arm")

local leftarm = Instance.new("Weld")
leftarm.Name = "Right Arm"
leftarm.Parent = Cestus2
leftarm.Part0 = Cestus2.zaza
leftarm.Part1 = character:FindFirstChild("Right Arm")
local katmesh = Katanamesh
katmesh.Transparency = 1


    character:FindFirstChildOfClass("Model").sord:Remove()
    character:FindFirstChildOfClass("Model").handle:Remove()
    character:FindFirstChildOfClass("Model"):FindFirstChild("WhiteFlameCharges"):Remove()
    character:FindFirstChildOfClass("Model"):FindFirstChild("Excalibur"):Remove()
end
})

local OniClaws = Skins:CreateButton({
   Name = "Funny Oni Claws",
   Callback = function()


local bindableFunction= Instance.new("BindableFunction")
game.StarterGui:SetCore("SendNotification", {
   Title = "Bilgi";
   Text = "Sucessfully use Oni Claws";
   Icon = "";
   Duration = 3;
   callbakc = bindableFunction;
   Button1 = "OK";
})

            
    local localplayer = game.Players.LocalPlayer
local character = localplayer.Character
local sword = character:FindFirstChildOfClass("Model")
local claws = game:GetService("ReplicatedStorage").Misc.Swords.Limited["Oni Claws"]:Clone()
local claws2 = game:GetService("ReplicatedStorage").Misc.Swords.Limited["Oni Claws"]:Clone()
local Katanamesh = character:FindFirstChildOfClass("Model"):FindFirstChild("KatanaMesh")
local Cestsu1 = claws.Cestus
local Cestsu2 = claws.Cestus2

local Glove = claws
local Glove2 = claws2
local Cestus1 = Glove:FindFirstChild("Cestus")
local Csetus2 = Glove2:FindFirstChild("Cestus2")
local Cestus1Blade = Cestus1:FindFirstChild("Meshes/oni claws textured_Cube.010_Cube.020")
local thing = Cestus1Blade
local Cestus2 = Glove:FindFirstChild("Cestus2")
local Csetus1 = Glove2:FindFirstChild("Cestus")

Glove.Parent = sword
local leftarm = Instance.new("Weld")
leftarm.Name = "Left Arm"
leftarm.Parent = Cestus1
leftarm.Part0 = Cestus1.zaza
leftarm.Part1 = character:FindFirstChild("Left Arm")

local leftarm = Instance.new("Weld")
leftarm.Name = "Right Arm"
leftarm.Parent = Cestus2
leftarm.Part0 = Cestus2.zaza
leftarm.Part1 = character:FindFirstChild("Right Arm")

Glove2.Parent = sword
local lfetarm = Instance.new("Weld")
lfetarm.Name = "Left Arm"
lfetarm.Parent = Csetus2
lfetarm.Part0 = Csetus2.zaza
lfetarm.Part1 = character:FindFirstChild("Left Arm")

local rarm = Instance.new("Weld")
rarm.Name = "Right Arm"
rarm.Parent = Csetus1
rarm.Part0 = Csetus1.zaza
rarm.Part1 = character:FindFirstChild("Right Arm")

            
local katmesh = Katanamesh
katmesh.Transparency = 1


    character:FindFirstChildOfClass("Model").sord:Remove()
    character:FindFirstChildOfClass("Model").handle:Remove()
    character:FindFirstChildOfClass("Model"):FindFirstChild("WhiteFlameCharges"):Remove()
    character:FindFirstChildOfClass("Model"):FindFirstChild("Excalibur"):Remove()
end
})

local Unique = Skins:CreateSection("Unique")

local GodSaber = Skins:CreateButton({
   Name = "God Saber",
   Callback = function()
            local localplayer = game.Players.LocalPlayer
local character = localplayer.Character
local Katanamesh = character:FindFirstChildOfClass("Model"):FindFirstChild("KatanaMesh")
local godsaber = game:GetService("ReplicatedStorage").Misc.Swords.Unique.Godsaber

local SkinSword = godsaber
local SkinSwordClone = godsaber:Clone()
local godkatanamesh = godsaber:FindFirstChild("KatanaMesh")
local godhandle = godsaber:FindFirstChild("handle")
local godsord = godsaber:FindFirstChild("sord")
local godBlade = godsaber:FindFirstChild("Blade")
local godMain = godBlade:FindFirstChild("Main")
local katmesh = Katanamesh
if character:FindFirstChildOfClass("Model"):FindFirstChild("Godsaber") then
    character:FindFirstChildOfClass("Model"):FindFirstChild("Godsaber"):Remove()

task.wait(0.1)

godMain.Anchored = false
godsord.Anchored = false
godhandle.Anchored = false
godkatanamesh.Anchored = false
SkinSwordClone.Parent = character:FindFirstChildOfClass("Model")

character.HumanoidRootPart.CFrame = CFrame.new(-233.710556, 123.299973, 203.648102)

godsord.CFrame = Katanamesh.CFrame
godhandle.CFrame = Katanamesh.CFrame + Vector3.new(0,0.6,-1.5)
godkatanamesh.CFrame = Katanamesh.CFrame
godMain.CFrame = Katanamesh.CFrame

godkatanamesh.WeldConstraint.Part1 = character:FindFirstChild("Left Leg")

task.wait(0.2)

godMain.Rotation = Vector3.new(112, 0, 90)

godhandle.Rotation = Vector3.new(-159, 0, 100)

katmesh.Transparency = 1

        Rayfield:Notify({
   Title = "Wave Hub",
   Content = "Sucessfully use Godsaber",
   Duration = 20,
   Image = 4483362458,
   Actions = { -- Notification Buttons
      Ignore = {
         Name = "OK",
         Callback = function()
         print("OK")
      end
   },
},
})
elseif not character:FindFirstChildOfClass("Model"):FindFirstChild("Godsaber") then
    godMain.Anchored = false
godsord.Anchored = false
godhandle.Anchored = false
godkatanamesh.Anchored = false
SkinSwordClone.Parent = character:FindFirstChildOfClass("Model")

character.HumanoidRootPart.CFrame = CFrame.new(-233.710556, 123.299973, 203.648102)

godsord.CFrame = Katanamesh.CFrame
godhandle.CFrame = Katanamesh.CFrame + Vector3.new(0,0.6,-1.5)
godkatanamesh.CFrame = Katanamesh.CFrame
godMain.CFrame = Katanamesh.CFrame

godkatanamesh.WeldConstraint.Part1 = character:FindFirstChild("Left Leg")

task.wait(0.2)

godMain.Rotation = Vector3.new(112, 0, 90)

godhandle.Rotation = Vector3.new(-159, 0, 100)


katmesh.Transparency = 1

    character:FindFirstChildOfClass("Model").sord:Remove()
    character:FindFirstChildOfClass("Model").handle:Remove()
    character:FindFirstChildOfClass("Model"):FindFirstChild("WhiteFlameCharges"):Remove()
    character:FindFirstChildOfClass("Model"):FindFirstChild("Excalibur"):Remove()

        Rayfield:Notify({
   Title = "Wave Hub",
   Content = "",
   Duration = 20,
   Image = 4483362458,
   Actions = { -- Notification Buttons
      Ignore = {
         Name = "OK",
         Callback = function()
         print("")
      end
   },
},
})
        end
    end
    })
    
